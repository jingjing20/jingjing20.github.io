(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{410:function(_,v,t){"use strict";t.r(v);var s=t(42),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"tcp-和-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-和-udp"}},[_._v("#")]),_._v(" TCP 和 UDP")]),_._v(" "),t("h3",{attrs:{id:"tcp-对比-udp-的区别总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-对比-udp-的区别总结"}},[_._v("#")]),_._v(" TCP 对比 UDP 的区别总结")]),_._v(" "),t("ul",[t("li",[_._v("1、TCP 是面向字节流————UDP 是面向报文的，UDP 没有拥塞控制，因此网络出现拥塞也不会使源主机的发送速率降低（对实时应用很有用，如实时聊天、实时视频通话等）。")]),_._v(" "),t("li",[_._v("2、TCP 是面向连接的（如打电话需要先拨号建立连接）————UDP 是无连接的，即发送数据前不需要建立连接。")]),_._v(" "),t("li",[_._v("3、TCP 提供可靠服务。即通过 TCP 连接传送的数据无差错、不丢失、不重复，且按发送顺序到达————UDP尽最大努力交付，即不保证可靠交付。")]),_._v(" "),t("li",[_._v("4、每一条 TCP 连接都只能是点到点的————UDP 支持一对多、一对一、多对一、多对多的交互通信。")]),_._v(" "),t("li",[_._v("5、TCP 首部开销大 20 字节————UDP 首部开销小 8 字节。")]),_._v(" "),t("li",[_._v("6、TCP 通信信道是全双工的可靠信道————UDP 则是不可靠信道。")])]),_._v(" "),t("h3",{attrs:{id:"udp应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp应用场景"}},[_._v("#")]),_._v(" UDP应用场景：")]),_._v(" "),t("ul",[t("li",[_._v("1.面向数据报方式")]),_._v(" "),t("li",[_._v("2.网络数据大多为短消息")]),_._v(" "),t("li",[_._v("3.拥有大量客户端——Client")]),_._v(" "),t("li",[_._v("4.对数据安全性无特殊要求")]),_._v(" "),t("li",[_._v("5.网络负担非常重，但对响应速度要求高")])]),_._v(" "),t("h2",{attrs:{id:"三次握手🤝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手🤝"}},[_._v("#")]),_._v(" 三次握手🤝")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。")])]),_._v(" "),t("li",[t("p",[_._v("进行三次握手的"),t("strong",[_._v("主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。")])])]),_._v(" "),t("li",[t("p",[_._v("实质上其实就是"),t("strong",[_._v("连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。")])])])]),_._v(" "),t("h3",{attrs:{id:"进行三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进行三次握手"}},[_._v("#")]),_._v(" 进行三次握手")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("1、第一次握手：客户端向服务端发送一个 SYN 报文，并同时指定一个 "),t("strong",[_._v("初始化序列号（后面会说到这个序列号的用处）")]),_._v("，客户端发完这个 SYN 报文后就处于 SYN_SEND 状态。首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。")])]),_._v(" "),t("li",[t("p",[_._v("2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。")])]),_._v(" "),t("li",[t("p",[_._v("3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。")])])]),_._v(" "),t("p",[_._v("确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。\n发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。")]),_._v(" "),t("h3",{attrs:{id:"为什么需要三次握手-两次不行吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要三次握手-两次不行吗"}},[_._v("#")]),_._v(" 为什么需要三次握手，两次不行吗？")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("上面已经讲到过进行三次握手的目的就是为了确定双方的接收和发送能力是否正常。")])]),_._v(" "),t("li",[t("p",[_._v("第一次握手：客户端发送网络包（客户端进入 SYN_SEND——半连接状态），服务端如果收到了（服务端进入 SYN_RCVD——半连接状态），服务端就能确定客户端的发送能力和服务端的接收能力是正常的。")])]),_._v(" "),t("li",[t("p",[_._v("第二次握手：服务端发送网络包，客户端如果收到了（客户端进入estalished状态——已建立连接的），客户端就能确定自己的发送和接收能力、服务端的接收和发送能力是正常的。（这时服务器还不能确定客户端的接收能力是正常的，所以需要第三次握手。）")])]),_._v(" "),t("li",[t("p",[_._v("第三次握手：客户端发送网络包，服务端收到了（服务端进入estalished状态——已建立连接的）。这样就能确定客户端服务端都有发送和接收的能力了。")])])]),_._v(" "),t("p",[t("font",{attrs:{color:"red"}},[_._v("如果只进行两次握手可能就会出现以下这种情况：")])],1),_._v(" "),t("p",[_._v("如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。")]),_._v(" "),t("h3",{attrs:{id:"什么是半连接队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是半连接队列"}},[_._v("#")]),_._v(" 什么是半连接队列")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。")])]),_._v(" "),t("li",[t("p",[_._v("当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。")])]),_._v(" "),t("li",[t("p",[_._v("这里在补充一点关于SYN-ACK 重传次数的问题："),t("strong",[_._v("服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。")])])])]),_._v(" "),t("p",[t("strong",[_._v("注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…")])]),_._v(" "),t("h3",{attrs:{id:"isn-initial-sequence-number-是固定的吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#isn-initial-sequence-number-是固定的吗"}},[_._v("#")]),_._v(" ISN(Initial Sequence Number)是固定的吗？")]),_._v(" "),t("ul",[t("li",[_._v("当一端为建立连接而发送它的 SYN 的时候，会为此次连接选择一个初始序号（ISN），ISN 会随时间变化，因此每个连接都会有一个不同的 ISN。")]),_._v(" "),t("li",[_._v("ISN 的存在可以防止在网络中被延迟的数据在之后又到达服务器而导致的服务器的处理错误。")])]),_._v(" "),t("h3",{attrs:{id:"三次握手可以携带数据吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手可以携带数据吗"}},[_._v("#")]),_._v(" 三次握手可以携带数据吗？")]),_._v(" "),t("ul",[t("li",[_._v("1、结论是第一次和第二次握手的时候不能携带数据，第三次握手可以携带数据。")]),_._v(" "),t("li",[_._v("2、第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。")]),_._v(" "),t("li",[_._v("3、而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。")])]),_._v(" "),t("h3",{attrs:{id:"syn攻击是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#syn攻击是什么"}},[_._v("#")]),_._v(" SYN攻击是什么？")]),_._v(" "),t("p",[_._v("SYN 攻击就是客户端（Client）在短时间内用大量伪造的不存在的IP地址向服务端（Server）不断的发送 SYN 包，服务端（Server）则需要回复确认包，并等待客户端（Client）确认，由于这些都是伪造的 IP 地址，所以根本就得不到客户端的确认，服务端就一直重传直至超时。由于这些伪造的 SYN 包长时间占用着半连接队列，导致正常的 SYN 请求因为队列已满而被丢弃，从而引起网络拥塞甚至系统瘫痪。")]),_._v(" "),t("p",[t("strong",[_._v("常见的几种防御 SYN 攻击的方法有一下几种：")])]),_._v(" "),t("ul",[t("li",[_._v("1、缩短超时时间（SYN Timeout）")]),_._v(" "),t("li",[_._v("2、增加最大半连接队列的容量")]),_._v(" "),t("li",[_._v("3、过滤网关防护")]),_._v(" "),t("li",[_._v("4、SYN cookies 技术")])]),_._v(" "),t("h2",{attrs:{id:"四次挥手👋"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手👋"}},[_._v("#")]),_._v(" 四次挥手👋")]),_._v(" "),t("blockquote",[t("p",[_._v("建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。这是由于 TCP 的半关闭状态（half-close）决定的。TCP 提供了连接的双方在发送了 FIN 报文结束了自己的发送后还有接收对方数据的能力。刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("1、第一次挥手：客户端发送一个 FIN=1 报文，报文中指定一个序列号 seq=u，客户端进入 "),t("code",[_._v("FIN_WAIT1")]),_._v("（终止等待一状态）。主动关闭 TCP 连接并停止发送数据。等待服务端的确认。")])]),_._v(" "),t("li",[t("p",[_._v("2、第二次挥手：服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入 "),t("code",[_._v("CLOSE_WAIT")]),_._v("（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 "),t("code",[_._v("FIN_WAIT2")]),_._v("（终止等待二状态），等待服务端发出的连接释放报文段。")])]),_._v(" "),t("li",[t("p",[_._v("3、第三次挥手：如果服务端没有要向客户端发送的数据了，也想要断开连接的话。服务端就会发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入"),t("code",[_._v("LAST_ACK")]),_._v("（最后确认）状态，等待客户端的确认。")])]),_._v(" "),t("li",[t("p",[_._v("4、第四次挥手：客户端收到服务端的 FIN 报文后，也会发送一个 ACK 确认报文然后进入 "),t("code",[_._v("TIME_WAIT")]),_._v("（2MSL等待状态）。服务端收到 ACK 报文后就会进入 "),t("code",[_._v("CLOSED")]),_._v("（关闭状态）。")])])]),_._v(" "),t("h3",{attrs:{id:"挥手为什么需要四次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#挥手为什么需要四次"}},[_._v("#")]),_._v(" 挥手为什么需要四次？")]),_._v(" "),t("blockquote",[t("p",[_._v("因为建立连接的时候服务端收到客户端发送的 SYN 连接请求报文后，可以同时发送 SYN + ACK 报文给客户端的。但是在断开连接的时候，"),t("strong",[_._v("服务端收到 FIN 报文后很可能不会立即关闭 SOCKET 连接，因为还有数据要传，必须等所有数据发送完后才能断开连接")]),_._v("。所以服务端就只能先发送一个 ACK 报文来告诉客户端，你发的 FIN 报文我收到了，等我发完数据后再给你发送 FIN 报文。")])]),_._v(" "),t("h3",{attrs:{id:"为什么会有-2msl-等待状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么会有-2msl-等待状态"}},[_._v("#")]),_._v(" 为什么会有 2MSL 等待状态？")]),_._v(" "),t("ul",[t("li",[_._v("1、保证客户端发送的最后一个ACK报文段能够到达服务端，使服务端能正常关闭。")])]),_._v(" "),t("blockquote",[t("p",[_._v("因为客户端发送的这个 ACK 确认报文有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK ，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态。")])]),_._v(" "),t("ul",[t("li",[_._v("2、防止“已失效的连接请求报文段”出现在本连接中。")])]),_._v(" "),t("blockquote",[t("p",[_._v("客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使得本次连接持续的时间内所产生的所有报文段都从网络中消失，保证下一个新的 TCP 连接中不会出现上一个 TCP 连接请求的报文段。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);